<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>함수2</title>
</head>
<body>
    
</body>
</html>
<script>
    /* === 콜백 함수 === */
    // 함수도 매개변수로 전달가능 -> 매개변수로 전달하는 함수 : 콜백(callback)함수

    // 특정처리후 실행해야 하는경우 사용
    // ex) javascript는 함수호출후 끝날때까지 기다리지 않는다. 
    // => 위의 문제를 해결하기 위하여 함수에 함수를 넣고 특정함수에서 코드가 다 끝나고나서 전달받는 함수를 실행 .
    // 웹 기반 통신을 할 때 비동기 상태에서의 통신을 보완할 수 있음.
    // 콜백 함수가 많을경우 코드의 가독성이 떨어진다. -> promise 를 대안으로 사용

    function callTenTimes(callback) {   // 10번 호출하는 함수 선언

        for (let i = 0; i < 10; i++) {
            console.log(i+1)
        }
        for (let index = 0; index < 10; index++) {
            callback()
        }
    }

    let fn = function(){    // 함수 호출 
        console.log('외부 함수')
    }

    // callTenTimes(fn);    // 선언한 함수를 (fn)으로 전달 

    // callTenTimes(function(){
    //     console.log('aaa')
    // })

    ///////////////////////////////////////
    /* forEach 메소드 */
    const arr = [1,2,3,4,5]

    arr.forEach(function(num,index){
        console.log(index, num)
    })

    console.log('')     // 줄 바꿈 (의미없음)

    // map()메소드 : 콜백 함수에서 리턴한 값들을 기반으로 새로운 배열을 만드는 함수
    let arr1 = arr.map(function(num,index){
        return num*num
    })

    // arr1.forEach(console.log)   // 함수를 던져줌
    arr1.forEach(function(num,index){
        console.log(index, num)
    })

    // filter()메소드 : 구분 | 콜백 함수에서 리턴하는 값이 true인 것들만 모아서 새로운 배열을 만드는 함수 
    // let arr2 = arr.filter(function(num, index){
    //     return num%2 == 0
    // })

    let arr2 = arr.filter(function(num, index){
        return num%2 == 0
    }).map(function(num, index){  // 2가지 처리가 가능하게 된다. map,forEach 다 가능 
        return num+10
    })

    console.log('')

    arr2.forEach(function(num,index){
        console.log(index, num)
    })
    
</script>